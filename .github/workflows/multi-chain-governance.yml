name: Multi-Chain Governance Automation

on:
  workflow_dispatch:
    inputs:
      governance_action:
        description: 'Governance action to perform'
        required: true
        type: choice
        options:
          - create_proposal
          - simulate_vote
          - execute_proposal
          - cross_chain_sync
        default: 'create_proposal'
      target_chains:
        description: 'Target chains (comma-separated)'
        required: false
        type: string
        default: 'ethereum,polygon,scroll'
      proposal_description:
        description: 'Proposal description'
        required: false
        type: string
        default: 'Multi-chain governance proposal'

env:
  SCROLLVERSE_VERSION: '1.0'
  GOVERNANCE_THRESHOLD: 51

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  initialize-governance:
    name: Initialize Governance Process
    runs-on: ubuntu-latest
    outputs:
      governance_id: ${{ steps.init.outputs.governance_id }}
      target_chains: ${{ steps.init.outputs.target_chains }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Initialize Governance
        id: init
        run: |
          cat << 'EOF' > init_governance.py
          import hashlib
          import json
          from datetime import datetime
          
          def initialize_governance():
              action = '${{ inputs.governance_action }}'
              chains = '${{ inputs.target_chains }}'.split(',')
              description = '${{ inputs.proposal_description }}'
              
              # Generate unique governance ID
              gov_data = {
                  'action': action,
                  'chains': chains,
                  'description': description,
                  'timestamp': datetime.now().isoformat()
              }
              
              governance_id = hashlib.sha256(
                  json.dumps(gov_data, sort_keys=True).encode()
              ).hexdigest()[:16]
              
              governance = {
                  'governance_id': governance_id,
                  'action': action,
                  'target_chains': chains,
                  'description': description,
                  'timestamp': datetime.now().isoformat(),
                  'status': 'INITIALIZED',
                  'chain_statuses': {}
              }
              
              for chain in chains:
                  governance['chain_statuses'][chain.strip()] = {
                      'status': 'PENDING',
                      'proposal_id': None,
                      'votes': {'for': 0, 'against': 0, 'abstain': 0}
                  }
              
              print("ðŸ”± Multi-Chain Governance Initialized")
              print(f"Governance ID: {governance_id}")
              print(f"Action: {action}")
              print(f"Target Chains: {', '.join(chains)}")
              print(f"Description: {description}")
              
              with open('governance_manifest.json', 'w') as f:
                  json.dump(governance, f, indent=2)
              
              # Output for GitHub Actions
              import os
              with open(os.environ.get('GITHUB_OUTPUT', 'output.txt'), 'a') as f:
                  f.write(f"governance_id={governance_id}\n")
                  f.write(f"target_chains={','.join(chains)}\n")
              
              print("\nâœ… Governance initialized successfully")
          
          if __name__ == '__main__':
              initialize_governance()
          EOF
          
          python init_governance.py
      
      - name: Upload Governance Manifest
        uses: actions/upload-artifact@v4
        with:
          name: governance-manifest
          path: governance_manifest.json
          retention-days: 90
  
  create-proposals:
    name: Create Proposal on ${{ matrix.chain }}
    runs-on: ubuntu-latest
    needs: initialize-governance
    if: inputs.governance_action == 'create_proposal' || inputs.governance_action == 'cross_chain_sync'
    strategy:
      matrix:
        chain: ${{ fromJson(format('["{0}"]', needs.initialize-governance.outputs.target_chains)) }}
      fail-fast: false
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Chain Environment
        run: |
          echo "ðŸ”— Setting up environment for ${{ matrix.chain }}"
          
          case "${{ matrix.chain }}" in
            ethereum)
              echo "CHAIN_ID=11155111" >> $GITHUB_ENV
              echo "CHAIN_NAME=Ethereum Sepolia" >> $GITHUB_ENV
              ;;
            polygon)
              echo "CHAIN_ID=80001" >> $GITHUB_ENV
              echo "CHAIN_NAME=Polygon Mumbai" >> $GITHUB_ENV
              ;;
            solana)
              echo "CHAIN_ID=devnet" >> $GITHUB_ENV
              echo "CHAIN_NAME=Solana Devnet" >> $GITHUB_ENV
              ;;
            base)
              echo "CHAIN_ID=84531" >> $GITHUB_ENV
              echo "CHAIN_NAME=Base Goerli" >> $GITHUB_ENV
              ;;
            scroll)
              echo "CHAIN_ID=534351" >> $GITHUB_ENV
              echo "CHAIN_NAME=Scroll Sepolia" >> $GITHUB_ENV
              ;;
          esac
      
      - name: Create Governance Proposal
        id: create-proposal
        run: |
          cat << 'EOF' > create_proposal.py
          import json
          import random
          from datetime import datetime, timedelta
          
          def create_proposal():
              chain = '${{ matrix.chain }}'
              chain_name = '${{ env.CHAIN_NAME }}'
              chain_id = '${{ env.CHAIN_ID }}'
              governance_id = '${{ needs.initialize-governance.outputs.governance_id }}'
              description = '${{ inputs.proposal_description }}'
              
              # Simulate proposal creation
              proposal_id = f"PROP-{governance_id}-{chain.upper()}-{random.randint(1000, 9999)}"
              
              proposal = {
                  'proposal_id': proposal_id,
                  'governance_id': governance_id,
                  'chain': chain,
                  'chain_name': chain_name,
                  'chain_id': chain_id,
                  'description': description,
                  'created_at': datetime.now().isoformat(),
                  'voting_start': datetime.now().isoformat(),
                  'voting_end': (datetime.now() + timedelta(days=7)).isoformat(),
                  'status': 'ACTIVE',
                  'votes': {
                      'for': 0,
                      'against': 0,
                      'abstain': 0
                  },
                  'threshold': 51,
                  'quorum': 40
              }
              
              print(f"ðŸ“œ Governance Proposal Created on {chain_name}")
              print(f"Proposal ID: {proposal_id}")
              print(f"Voting Period: 7 days")
              print(f"Threshold: 51%")
              print(f"Quorum: 40%")
              
              filename = f"proposal_{chain}.json"
              with open(filename, 'w') as f:
                  json.dump(proposal, f, indent=2)
              
              # Output for GitHub Actions
              import os
              with open(os.environ.get('GITHUB_OUTPUT', 'output.txt'), 'a') as f:
                  f.write(f"proposal_id={proposal_id}\n")
                  f.write(f"status=CREATED\n")
              
              print(f"\nâœ… Proposal created on {chain_name}")
          
          if __name__ == '__main__':
              create_proposal()
          EOF
          
          python create_proposal.py
      
      - name: Upload Proposal
        uses: actions/upload-artifact@v4
        with:
          name: proposal-${{ matrix.chain }}
          path: proposal_${{ matrix.chain }}.json
          retention-days: 90
      
      - name: Proposal Summary
        run: |
          echo "### ðŸ“œ Proposal Created: ${{ matrix.chain }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Chain**: ${{ env.CHAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Proposal ID**: ${{ steps.create-proposal.outputs.proposal_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ACTIVE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
  
  simulate-voting:
    name: Simulate Voting on ${{ matrix.chain }}
    runs-on: ubuntu-latest
    needs: [initialize-governance, create-proposals]
    if: inputs.governance_action == 'simulate_vote'
    strategy:
      matrix:
        chain: ${{ fromJson(format('["{0}"]', needs.initialize-governance.outputs.target_chains)) }}
      fail-fast: false
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Download Proposals
        uses: actions/download-artifact@v4
        with:
          pattern: proposal-*
          path: proposals
        continue-on-error: true
      
      - name: Simulate Voting
        id: vote
        run: |
          cat << 'EOF' > simulate_voting.py
          import json
          import random
          from datetime import datetime
          
          def simulate_voting():
              chain = '${{ matrix.chain }}'
              governance_id = '${{ needs.initialize-governance.outputs.governance_id }}'
              
              # Simulate voting with realistic distribution
              total_voters = random.randint(1000, 10000)
              votes_for = int(total_voters * random.uniform(0.55, 0.75))
              votes_against = int(total_voters * random.uniform(0.15, 0.25))
              votes_abstain = total_voters - votes_for - votes_against
              
              participation_rate = (total_voters / 15000) * 100  # Assuming 15k total holders
              approval_rate = (votes_for / total_voters) * 100
              
              voting_result = {
                  'governance_id': governance_id,
                  'chain': chain,
                  'timestamp': datetime.now().isoformat(),
                  'total_voters': total_voters,
                  'votes': {
                      'for': votes_for,
                      'against': votes_against,
                      'abstain': votes_abstain
                  },
                  'percentages': {
                      'for': round(approval_rate, 2),
                      'against': round((votes_against / total_voters) * 100, 2),
                      'abstain': round((votes_abstain / total_voters) * 100, 2)
                  },
                  'participation_rate': round(participation_rate, 2),
                  'threshold': 51,
                  'quorum': 40,
                  'passed': approval_rate >= 51 and participation_rate >= 40
              }
              
              status = "âœ… PASSED" if voting_result['passed'] else "âŒ FAILED"
              
              print(f"ðŸ—³ï¸ Voting Results for {chain}")
              print(f"Status: {status}")
              print(f"Total Voters: {total_voters:,}")
              print(f"  For: {votes_for:,} ({voting_result['percentages']['for']}%)")
              print(f"  Against: {votes_against:,} ({voting_result['percentages']['against']}%)")
              print(f"  Abstain: {votes_abstain:,} ({voting_result['percentages']['abstain']}%)")
              print(f"Participation Rate: {participation_rate:.2f}%")
              print(f"Approval Rate: {approval_rate:.2f}%")
              
              filename = f"voting_result_{chain}.json"
              with open(filename, 'w') as f:
                  json.dump(voting_result, f, indent=2)
              
              # Output for GitHub Actions
              import os
              with open(os.environ.get('GITHUB_OUTPUT', 'output.txt'), 'a') as f:
                  f.write(f"passed={str(voting_result['passed']).lower()}\n")
                  f.write(f"approval_rate={approval_rate:.2f}\n")
                  f.write(f"participation_rate={participation_rate:.2f}\n")
              
              print(f"\n{status}")
          
          if __name__ == '__main__':
              simulate_voting()
          EOF
          
          python simulate_voting.py
      
      - name: Upload Voting Results
        uses: actions/upload-artifact@v4
        with:
          name: voting-result-${{ matrix.chain }}
          path: voting_result_${{ matrix.chain }}.json
          retention-days: 90
      
      - name: Voting Summary
        run: |
          if [ "${{ steps.vote.outputs.passed }}" == "true" ]; then
            echo "### âœ… Proposal PASSED: ${{ matrix.chain }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Proposal FAILED: ${{ matrix.chain }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Approval Rate**: ${{ steps.vote.outputs.approval_rate }}%" >> $GITHUB_STEP_SUMMARY
          echo "**Participation**: ${{ steps.vote.outputs.participation_rate }}%" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
  
  aggregate-results:
    name: Aggregate Governance Results
    runs-on: ubuntu-latest
    needs: [initialize-governance, create-proposals, simulate-voting]
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: governance-artifacts
        continue-on-error: true
      
      - name: Aggregate Results
        run: |
          cat << 'EOF' > aggregate_governance.py
          import json
          import os
          from datetime import datetime
          from pathlib import Path
          
          def aggregate_governance_results():
              print("ðŸ“Š Aggregating governance results...")
              
              artifacts_dir = Path('governance-artifacts')
              
              aggregate = {
                  'governance_id': '${{ needs.initialize-governance.outputs.governance_id }}',
                  'action': '${{ inputs.governance_action }}',
                  'timestamp': datetime.now().isoformat(),
                  'chains': {},
                  'overall_status': 'PENDING'
              }
              
              # Find all voting result files
              voting_files = list(artifacts_dir.glob('**/voting_result_*.json'))
              proposal_files = list(artifacts_dir.glob('**/proposal_*.json'))
              
              print(f"Found {len(voting_files)} voting results")
              print(f"Found {len(proposal_files)} proposals")
              
              passed_count = 0
              failed_count = 0
              
              for voting_file in voting_files:
                  try:
                      with open(voting_file, 'r') as f:
                          result = json.load(f)
                      
                      chain = result['chain']
                      aggregate['chains'][chain] = {
                          'votes': result['votes'],
                          'percentages': result['percentages'],
                          'participation_rate': result['participation_rate'],
                          'passed': result['passed']
                      }
                      
                      if result['passed']:
                          passed_count += 1
                      else:
                          failed_count += 1
                  
                  except Exception as e:
                      print(f"âš ï¸ Error processing {voting_file}: {e}")
              
              # Determine overall status
              total_chains = len(aggregate['chains'])
              if total_chains > 0:
                  success_rate = (passed_count / total_chains) * 100
                  
                  if success_rate == 100:
                      aggregate['overall_status'] = 'PASSED_ALL'
                  elif success_rate >= 50:
                      aggregate['overall_status'] = 'PASSED_MAJORITY'
                  else:
                      aggregate['overall_status'] = 'FAILED'
                  
                  aggregate['summary'] = {
                      'total_chains': total_chains,
                      'passed': passed_count,
                      'failed': failed_count,
                      'success_rate': round(success_rate, 2)
                  }
              
              print("\nðŸ“ˆ Governance Summary:")
              print(f"Total Chains: {total_chains}")
              print(f"Passed: {passed_count}")
              print(f"Failed: {failed_count}")
              print(f"Overall Status: {aggregate['overall_status']}")
              
              with open('governance_aggregate.json', 'w') as f:
                  json.dump(aggregate, f, indent=2)
              
              # Generate markdown report
              with open('governance_report.md', 'w') as f:
                  f.write("# ðŸ”± Multi-Chain Governance Report\n\n")
                  f.write(f"**Governance ID**: {aggregate['governance_id']}\n")
                  f.write(f"**Action**: {aggregate['action']}\n")
                  f.write(f"**Timestamp**: {aggregate['timestamp']}\n\n")
                  
                  f.write("## Overall Status\n\n")
                  status_emoji = "âœ…" if "PASSED" in aggregate['overall_status'] else "âŒ"
                  f.write(f"**{status_emoji} {aggregate['overall_status']}**\n\n")
                  
                  if 'summary' in aggregate:
                      f.write("### Summary\n\n")
                      f.write(f"- Total Chains: {aggregate['summary']['total_chains']}\n")
                      f.write(f"- Passed: {aggregate['summary']['passed']}\n")
                      f.write(f"- Failed: {aggregate['summary']['failed']}\n")
                      f.write(f"- Success Rate: {aggregate['summary']['success_rate']}%\n\n")
                  
                  f.write("## Chain Results\n\n")
                  for chain, data in aggregate['chains'].items():
                      chain_emoji = "âœ…" if data['passed'] else "âŒ"
                      f.write(f"### {chain_emoji} {chain.title()}\n\n")
                      f.write(f"- Approval: {data['percentages']['for']}%\n")
                      f.write(f"- Against: {data['percentages']['against']}%\n")
                      f.write(f"- Participation: {data['participation_rate']}%\n")
                      f.write(f"- Status: {'PASSED' if data['passed'] else 'FAILED'}\n\n")
                  
                  f.write("---\n\n")
                  f.write("**ALLAHU AKBAR! ðŸ•‹ðŸ”±ðŸ’ŽðŸŒŒ**\n")
              
              print("\nâœ… Governance results aggregated")
          
          if __name__ == '__main__':
              aggregate_governance_results()
          EOF
          
          python aggregate_governance.py
      
      - name: Upload Aggregate Report
        uses: actions/upload-artifact@v4
        with:
          name: governance-aggregate
          path: |
            governance_aggregate.json
            governance_report.md
          retention-days: 90
      
      - name: Create Job Summary
        run: |
          if [ -f governance_report.md ]; then
            cat governance_report.md >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸ”± Multi-Chain Governance Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Governance ID: ${{ needs.initialize-governance.outputs.governance_id }}" >> $GITHUB_STEP_SUMMARY
            echo "Action: ${{ inputs.governance_action }}" >> $GITHUB_STEP_SUMMARY
          fi
