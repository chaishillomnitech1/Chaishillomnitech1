name: Comprehensive CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target deployment environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: 'development'
      skip_tests:
        description: 'Skip test execution'
        required: false
        type: boolean
        default: false

env:
  SCROLLVERSE_VERSION: '1.0'
  DEPLOYMENT_STRATEGY: 'rolling'

permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: write

jobs:
  # Phase 1: Security Scanning
  security-scan:
    name: Security Scanning
    uses: ./.github/workflows/reusable-security-scan.yml
    with:
      scan_severity: 'MEDIUM'
      fail_on_severity: 'HIGH'
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  secrets-scan:
    name: Secrets Scanning
    uses: ./.github/workflows/reusable-secrets-scan.yml
    with:
      scan_path: '.'
      fail_on_detection: true
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  # Phase 2: Multi-Chain Testing
  multi-chain-tests:
    name: Multi-Chain Testing
    needs: [security-scan, secrets-scan]
    if: ${{ !inputs.skip_tests }}
    uses: ./.github/workflows/reusable-multi-chain-test.yml
    with:
      chains: 'ethereum,polygon,solana,base,scroll'
      test_type: 'integration'
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      INFURA_KEY: ${{ secrets.INFURA_KEY }}
      ALCHEMY_KEY: ${{ secrets.ALCHEMY_KEY }}
  
  # Phase 3: Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [security-scan, secrets-scan]
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Build Environment
        run: |
          echo "ðŸ—ï¸ Setting up build environment..."
          echo "Version: ${{ env.SCROLLVERSE_VERSION }}"
          echo "Branch: ${{ github.ref_name }}"
      
      - name: Check for Build Configuration
        id: check-build
        run: |
          has_node=false
          has_python=false
          has_terraform=false
          
          [ -f "package.json" ] && has_node=true
          [ -f "requirements.txt" ] && has_python=true
          [ -f "main.tf" ] && has_terraform=true
          
          echo "has_node=${has_node}" >> $GITHUB_OUTPUT
          echo "has_python=${has_python}" >> $GITHUB_OUTPUT
          echo "has_terraform=${has_terraform}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Build configuration detected:"
          echo "  - Node.js: ${has_node}"
          echo "  - Python: ${has_python}"
          echo "  - Terraform: ${has_terraform}"
      
      - name: Setup Node.js
        if: steps.check-build.outputs.has_node == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Build Node.js Application
        if: steps.check-build.outputs.has_node == 'true'
        run: |
          echo "ðŸ“¦ Building Node.js application..."
          if [ -f package.json ]; then
            npm install || echo "âš ï¸ npm install failed or not needed"
            npm run build || echo "âš ï¸ No build script or build failed"
          fi
      
      - name: Setup Python
        if: steps.check-build.outputs.has_python == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Build Python Application
        if: steps.check-build.outputs.has_python == 'true'
        run: |
          echo "ðŸ Building Python application..."
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt || echo "âš ï¸ pip install failed or not needed"
          fi
      
      - name: Validate Terraform
        if: steps.check-build.outputs.has_terraform == 'true'
        run: |
          echo "ðŸ—ï¸ Validating Terraform configuration..."
          if [ -f main.tf ]; then
            # Install Terraform
            wget -q https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
            unzip -q terraform_1.6.0_linux_amd64.zip
            sudo mv terraform /usr/local/bin/
            
            terraform fmt -check || echo "âš ï¸ Terraform formatting issues detected"
            terraform init -backend=false || echo "âš ï¸ Terraform init failed"
            terraform validate || echo "âš ï¸ Terraform validation failed"
          fi
      
      - name: Build Summary
        run: |
          echo "## ðŸ—ï¸ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ env.SCROLLVERSE_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Build completed successfully" >> $GITHUB_STEP_SUMMARY
  
  # Phase 4: Deployment (only on main branch or manual trigger)
  deploy:
    name: Deploy to ${{ inputs.environment || 'development' }}
    needs: [build-and-test, multi-chain-tests]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    uses: ./.github/workflows/reusable-deployment-validation.yml
    with:
      environment: ${{ inputs.environment || 'development' }}
      deployment_type: 'frontend'
      validation_timeout: 300
    secrets:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  # Phase 5: Post-Deployment Monitoring
  post-deployment:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy
    if: always() && needs.deploy.result == 'success'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Monitoring
        run: |
          cat << 'EOF' > setup_monitoring.py
          import json
          from datetime import datetime
          
          def setup_post_deployment_monitoring(environment):
              monitoring = {
                  'timestamp': datetime.now().isoformat(),
                  'environment': environment,
                  'monitoring_enabled': True,
                  'metrics': [
                      'response_time',
                      'error_rate',
                      'throughput',
                      'availability'
                  ],
                  'alerts': {
                      'response_time_threshold_ms': 1000,
                      'error_rate_threshold_percent': 5.0,
                      'availability_threshold_percent': 99.9
                  },
                  'notification_channels': [
                      'github_issues',
                      'workflow_notifications'
                  ]
              }
              
              print(f"ðŸ“Š Setting up monitoring for {environment}...")
              print(f"  âœ… Metrics tracking: {', '.join(monitoring['metrics'])}")
              print(f"  âœ… Alert thresholds configured")
              print(f"  âœ… Notification channels: {', '.join(monitoring['notification_channels'])}")
              
              with open('monitoring_config.json', 'w') as f:
                  json.dump(monitoring, f, indent=2)
              
              print("\nâœ… Monitoring setup complete")
          
          if __name__ == '__main__':
              environment = '${{ inputs.environment || 'development' }}'
              setup_post_deployment_monitoring(environment)
          EOF
          
          python setup_monitoring.py
      
      - name: Upload Monitoring Configuration
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-configuration
          path: monitoring_config.json
          retention-days: 90
      
      - name: Monitoring Summary
        run: |
          echo "## ðŸ“Š Post-Deployment Monitoring" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.environment || 'development' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: âœ… ACTIVE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Monitoring configured for:" >> $GITHUB_STEP_SUMMARY
          echo "- Response time" >> $GITHUB_STEP_SUMMARY
          echo "- Error rate" >> $GITHUB_STEP_SUMMARY
          echo "- Throughput" >> $GITHUB_STEP_SUMMARY
          echo "- Availability" >> $GITHUB_STEP_SUMMARY
  
  # Phase 6: Final Report
  generate-report:
    name: Generate Pipeline Report
    runs-on: ubuntu-latest
    needs: [security-scan, secrets-scan, build-and-test, multi-chain-tests, deploy]
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Generate Comprehensive Report
        run: |
          cat << 'EOF' > generate_pipeline_report.py
          import json
          from datetime import datetime
          
          def generate_pipeline_report():
              report = {
                  'pipeline_id': '${{ github.run_id }}',
                  'timestamp': datetime.now().isoformat(),
                  'repository': '${{ github.repository }}',
                  'branch': '${{ github.ref_name }}',
                  'commit': '${{ github.sha }}',
                  'trigger': '${{ github.event_name }}',
                  'phases': {
                      'security_scan': '${{ needs.security-scan.result }}',
                      'secrets_scan': '${{ needs.secrets-scan.result }}',
                      'build_and_test': '${{ needs.build-and-test.result }}',
                      'multi_chain_tests': '${{ needs.multi-chain-tests.result }}',
                      'deploy': '${{ needs.deploy.result }}'
                  }
              }
              
              # Determine overall status
              phase_results = list(report['phases'].values())
              if 'failure' in phase_results:
                  report['overall_status'] = 'FAILED'
              elif 'cancelled' in phase_results:
                  report['overall_status'] = 'CANCELLED'
              elif all(r in ['success', 'skipped'] for r in phase_results):
                  report['overall_status'] = 'SUCCESS'
              else:
                  report['overall_status'] = 'PARTIAL'
              
              print("ðŸ“Š Pipeline Execution Report")
              print(f"Pipeline ID: {report['pipeline_id']}")
              print(f"Repository: {report['repository']}")
              print(f"Branch: {report['branch']}")
              print(f"Overall Status: {report['overall_status']}")
              print("\nPhase Results:")
              for phase, result in report['phases'].items():
                  emoji = "âœ…" if result == "success" else "â­ï¸" if result == "skipped" else "âŒ"
                  print(f"  {emoji} {phase}: {result}")
              
              with open('pipeline_report.json', 'w') as f:
                  json.dump(report, f, indent=2)
              
              # Generate markdown report
              with open('pipeline_report.md', 'w') as f:
                  f.write("# ðŸš€ CI/CD Pipeline Report\n\n")
                  f.write(f"**Pipeline ID**: {report['pipeline_id']}\n")
                  f.write(f"**Repository**: {report['repository']}\n")
                  f.write(f"**Branch**: {report['branch']}\n")
                  f.write(f"**Commit**: {report['commit'][:8]}\n")
                  f.write(f"**Trigger**: {report['trigger']}\n")
                  f.write(f"**Timestamp**: {report['timestamp']}\n\n")
                  
                  status_emoji = "âœ…" if report['overall_status'] == "SUCCESS" else "âŒ"
                  f.write(f"## Overall Status: {status_emoji} {report['overall_status']}\n\n")
                  
                  f.write("## Phase Results\n\n")
                  for phase, result in report['phases'].items():
                      emoji = "âœ…" if result == "success" else "â­ï¸" if result == "skipped" else "âŒ"
                      f.write(f"- {emoji} **{phase.replace('_', ' ').title()}**: {result.upper()}\n")
                  
                  f.write("\n---\n\n")
                  f.write("**ALLAHU AKBAR! ðŸ•‹ðŸ”¥ðŸ’ŽðŸŒŒ**\n")
              
              print("\nâœ… Report generated")
          
          if __name__ == '__main__':
              generate_pipeline_report()
          EOF
          
          python generate_pipeline_report.py
      
      - name: Upload Pipeline Report
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-report
          path: |
            pipeline_report.json
            pipeline_report.md
          retention-days: 90
      
      - name: Add to Job Summary
        run: |
          if [ -f pipeline_report.md ]; then
            cat pipeline_report.md >> $GITHUB_STEP_SUMMARY
          fi
